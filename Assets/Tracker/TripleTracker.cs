using System.Collections.Generic;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.XR.MagicLeap;
using UnityEngine.InputSystem;
using PeterO.Cbor;

public class TripleTracker : MonoBehaviour
{
    public GameObject trackedObject;

    // marker settings
    private GameObject _marker0;

    // This was autogenerated and allows developers to create a dynamic
    // instance of an InputActionAsset which includes predefined action maps
    // that correspond to all of the Magic Leap 2's input.
    private MagicLeapInputs _magicLeapInputs;
    
    // This class is an Action Map and was autogenerated by the Unity Input
    // System and includes predefined bindings for the Magic Leap 2 Controller
    // Input Events.
    private MagicLeapInputs.ControllerActions _controllerActions;

    private bool _originFound=false;

    private void Start()
    {
        Debug.Log("OriginTracker::Start()");
        // create a tracker settings object with variables defined above
        MLMarkerTracker.ArucoDictionaryName d = MLMarkerTracker.ArucoDictionaryName.DICT_5X5_100;
        MLMarkerTracker.Profile profile = MLMarkerTracker.Profile.Accuracy;
        // create a tracker settings object with variables defined above
        MLMarkerTracker.TrackerSettings trackerSettings = MLMarkerTracker.TrackerSettings.Create(true, MLMarkerTracker.MarkerType.Aruco_April, 0.07161f, d, 0.07161f, profile);

      //Initialize the MagicLeapInputs like you would Unity's default action map.
       _magicLeapInputs = new MagicLeapInputs();
       _magicLeapInputs.Enable();
       //Initialize the ControllerActions based off the Magic Leap Input
       _controllerActions = new MagicLeapInputs.ControllerActions(_magicLeapInputs);
       _controllerActions.Trigger.started += HandleOnTriggerPull;
       _controllerActions.Trigger.canceled += HandleOnTriggerRelease;

        // start marker tracking with tracker settings object
        _ = MLMarkerTracker.SetSettingsAsync(trackerSettings);
    }

    // subscribe to the event that detects markers
    private void OnEnable()
    {
        Debug.Log("OriginTracker::OnEnable()");
        MLMarkerTracker.OnMLMarkerTrackerResultsFound += OnTrackerResultsFound;
    }

    // when the marker is detected...
    private void OnTrackerResultsFound(MLMarkerTracker.MarkerData data)
    {
        string id = "";

        if (!_originFound)
        {
            if (data.Type == MLMarkerTracker.MarkerType.Aruco_April)
            {
                id = data.ArucoData.Id.ToString();
            }

            //marker.transform.position = data.Pose.position + this.transform.rotation * new Vector3(-1.0f,0.0f,0f);
            //marker.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);

            Debug.Log("OriginTracker Detected " + id);

            if (id == "1")
            {
                Debug.Log("OriginTracker::1");
                trackedObject.SetActive(false);
                trackedObject.transform.GetChild(4).gameObject.GetComponent<TextMeshPro>().text = "ROOT";

                this.transform.position = data.Pose.position;// - new Vector3(0.0381f, 0.0f, -0.0381f);
                this.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);

                if (!_marker0) 
                {
                    _marker0 = Instantiate(trackedObject, data.Pose.position, data.Pose.rotation);
                    _marker0.transform.GetChild(4).gameObject.GetComponent<TextMeshPro>().text = id;
                    _marker0.transform.up = Vector3.up;
                    _marker0.SetActive(true);
                }

                _marker0.transform.position = data.Pose.position;
                _marker0.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);
            }

            if (_controllerActions.Trigger.ReadValue<float>()==0)
            {
                trackedObject.SetActive(false);

                var n_root = transform.Find("NoodlesRoot");

                if (n_root) {
                    Debug.Log("Kicking off transform request");

                    var panel_name = "DTrack";

                    var args = new List<CBORObject>();
                    args.Add(CBORObject.FromObject(panel_name));

                    var comp = n_root.gameObject.GetComponent<NOODLESRoot>();

                    if (comp != null)
                    {
                        Debug.Log("INVOKE");
                        comp.invoke_method_by_name("get_transform",  args, OnRequestReply);
                    }

                    
                }

                _originFound = true;
            }
        }           
        // stop scanning after object has been instantiated
        //_ = MLMarkerTracker.StopScanningAsync();

    }

    // Handles the event for the Trigger.
    private void HandleOnTriggerPull(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("Pull. The Trigger value is : " +  triggerValue);
        _originFound = false;
    }
        private void HandleOnTriggerRelease(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("Release. The Trigger value is : " +  triggerValue);
        _originFound = true;

    }

    private void OnRequestReply(CBORObject reply) {
        Debug.Log("RQ REPLY" + reply.ToString());


        var offset = new Vector3(
            reply[0].ToObject<float>(),
            reply[1].ToObject<float>(), 
            - reply[2].ToObject<float>()
        );

        var rotation = new Quaternion(
            -reply[3].ToObject<float>(),
            -reply[4].ToObject<float>(), 
            reply[5].ToObject<float>(),
            reply[6].ToObject<float>()
        );

        var n_root = transform.Find("NoodlesRoot");

        if (n_root == null)
        {
            Debug.Log("Unable to find root!");
            return;
        }

        n_root.SetLocalPositionAndRotation(offset, rotation);
    }
}
