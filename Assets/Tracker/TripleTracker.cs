using System;
using System.Collections.Generic;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.XR.MagicLeap;
using UnityEngine.InputSystem;
using PeterO.Cbor;

public class TripleTracker : MonoBehaviour
{
    public GameObject trackedObject;

    // marker settings
    public string aruco_id = "0";
    public string vrpn_id = "origin";
        
    // This was autogenerated and allows developers to create a dynamic
    // instance of an InputActionAsset which includes predefined action maps
    // that correspond to all of the Magic Leap 2's input.
    private MagicLeapInputs _magicLeapInputs;
    
    // This class is an Action Map and was autogenerated by the Unity Input
    // System and includes predefined bindings for the Magic Leap 2 Controller
    // Input Events.
    private MagicLeapInputs.ControllerActions _controllerActions;

    private bool _originFinding=true;

    private void Start()
    {
        Debug.Log("OriginTracker::Start()");
        // create a tracker settings object with variables defined above
        MLMarkerTracker.ArucoDictionaryName d = MLMarkerTracker.ArucoDictionaryName.DICT_5X5_100;
        MLMarkerTracker.Profile profile = MLMarkerTracker.Profile.Accuracy;
        // create a tracker settings object with variables defined above
        MLMarkerTracker.TrackerSettings trackerSettings = MLMarkerTracker.TrackerSettings.Create(true, MLMarkerTracker.MarkerType.Aruco_April, 0.07161f, d, 0.07161f, profile);

      //Initialize the MagicLeapInputs like you would Unity's default action map.
       _magicLeapInputs = new MagicLeapInputs();
       _magicLeapInputs.Enable();
       //Initialize the ControllerActions based off the Magic Leap Input
       _controllerActions = new MagicLeapInputs.ControllerActions(_magicLeapInputs);
       _controllerActions.Trigger.started += HandleOnTriggerPull;
       _controllerActions.Trigger.canceled += HandleOnTriggerRelease;
       //_controllerActions.Bumper.performed += HandleOnBumper;
       _controllerActions.Bumper.canceled += HandleOnBumperRelease;

        trackedObject.SetActive(true);
        trackedObject.transform.GetChild(4).gameObject.GetComponent<TextMeshPro>().text = "Release Trigger when aligned with the FLC ORIGIN";

        // start marker tracking with tracker settings object
        _ = MLMarkerTracker.SetSettingsAsync(trackerSettings);
    }

    // subscribe to the event that detects markers
    private void OnEnable()
    {
        Debug.Log("OriginTracker::OnEnable()");
        MLMarkerTracker.OnMLMarkerTrackerResultsFound += OnTrackerResultsFound;
    }

    // when the marker is detected...
    private void OnTrackerResultsFound(MLMarkerTracker.MarkerData data)
    {
        string id = "";

        if (_originFinding)
        {
            if (data.Type == MLMarkerTracker.MarkerType.Aruco_April)
            {
                id = data.ArucoData.Id.ToString();
            }

            Debug.Log("OriginTracker Detected " + id + " " + _controllerActions.Trigger.ReadValue<float>());

            if (id == aruco_id)
            {
                Debug.Log("OriginTracker updating " + id + " " + data.Pose.position);
                this.transform.position = data.Pose.position;// - new Vector3(0.0381f, 0.0f, -0.0381f);
                this.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);

                trackedObject.transform.GetChild(4).gameObject.SetActive(true);

                trackedObject.transform.position = data.Pose.position;
                trackedObject.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);
            
                //if (_controllerActions.Trigger.ReadValue<float>()==0)
                
            }
        }           
        // stop scanning after object has been instantiated
        //_ = MLMarkerTracker.StopScanningAsync();

    }

    // Handles the event for the Trigger.
    private void HandleOnTriggerPull(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("OriginTracker: Pull. The Trigger value is : " +  triggerValue);
        trackedObject.transform.GetChild(4).gameObject.SetActive(true);
        _originFinding = true;
    }
    
    private void HandleOnTriggerRelease(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("OriginTracker: Release. The Trigger value is : " +  triggerValue);
        trackedObject.transform.GetChild(4).gameObject.SetActive(false);
        _originFinding = false;

        try 
        {
            var n_root = GameObject.FindWithTag("NoodlesRootItem");

            if (n_root) {
                Debug.Log("OriginTracker: Kicking off transform request");

                var args = new List<CBORObject>();
                args.Add(CBORObject.FromObject(vrpn_id));

                var comp = n_root.GetComponent<NOODLESRoot>();

                if (comp != null)
                {
                    Debug.Log("OrignTracker: INVOKE");
                    comp.invoke_method_by_name("get_transform",  args, OnRequestReply);
                }                        
            }
            
            Debug.Log("OriginTracker: finished originFinding");
        }
        catch (Exception e) 
        {
            Debug.LogException(e);
        }

    }

    private void Update()
    {
        if (_controllerActions.Bumper.IsPressed())
        {
            var controllerPosition = _controllerActions.Position.ReadValue<Vector3>();
            var controllerRotation = _controllerActions.Rotation.ReadValue<Quaternion>();
            Debug.Log("Controller: " + controllerPosition + " " + controllerRotation);
                
            try 
            {
                var n_root = GameObject.FindWithTag("NoodlesRootItem");
                //var world_pos = n_root.transform.TransformPoint(controllerPosition);
                var forward_pos = controllerRotation * Vector3.forward + controllerPosition;
                var root_offset = forward_pos - n_root.transform.position ;
                var world_pos = new Vector3(root_offset[2], 
                                            root_offset[1],
                                            root_offset[0]);

                if (n_root) {
                    var args = new List<CBORObject>();
                    args.Add(CBORObject.FromObject(world_pos));

                    var comp = n_root.GetComponent<NOODLESRoot>();

                    if (comp != null)
                    {
                        Debug.Log("OrignTracker: INVOKE move");
                        comp.invoke_method_by_name("move_object",  args, NoReply);
                    }                        
                }
            }
            catch (Exception e) 
            {
                Debug.LogException(e);
            }
        }
    }
    private void HandleOnBumperRelease(InputAction.CallbackContext obj)
    {
        bool bumperDown = obj.ReadValueAsButton();
        Debug.Log("The Bumper released " + bumperDown);

        try 
        {
            var n_root = GameObject.FindWithTag("NoodlesRootItem");

            if (n_root) {
                var args = new List<CBORObject>();
                var comp = n_root.GetComponent<NOODLESRoot>();

                if (comp != null)
                {
                    Debug.Log("OrignTracker: INVOKE move");
                    comp.invoke_method_by_name("object_moved",  args, NoReply);
                }                        
            }
        }
        catch (Exception e) 
        {
            Debug.LogException(e);
        }
    }

    private void OnRequestReply(CBORObject reply) {
        Debug.Log("OriginTracker: RQ REPLY" + reply.ToString());

        var transform_array = reply["result"];


        var offset = new Vector3(
            transform_array[0].ToObject<float>(),
            transform_array[1].ToObject<float>(), 
            -transform_array[2].ToObject<float>()
        );

        var rotation = new Quaternion(
            transform_array[3].ToObject<float>(),
            transform_array[4].ToObject<float>(), 
            -transform_array[5].ToObject<float>(),
            -transform_array[6].ToObject<float>()
        );

        var n_root = GameObject.FindWithTag("NoodlesRootItem");
        var n_room_offset = GameObject.FindWithTag("OriginOffsetItem");
        var indicator = GameObject.FindWithTag("CoordinateIndicator");



        if (n_root == null || n_room_offset == null || indicator == null)
        {
            Debug.Log("Unable to find root or root offset nodes, we cannot properly set the origin for this client!");
            return;
        }

        n_root.transform.localPosition = offset;
        n_room_offset.transform.localRotation = rotation;

        // set the indicator as the inverse of this transform
        var tf_a = n_root.transform;
        var tf_b = transform;

        var indicator_pos = tf_a.InverseTransformPoint(tf_b.position);
        var indicator_rot = Quaternion.Inverse(tf_a.rotation) * tf_b.rotation;

        indicator.transform.SetLocalPositionAndRotation(indicator_pos, indicator_rot);

    }

    private void NoReply(CBORObject reply) {
    }
}
