using System.Collections.Generic;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.XR.MagicLeap;
using UnityEngine.InputSystem;
using PeterO.Cbor;

public class TripleTracker : MonoBehaviour
{
    class Panel 
    {
        public string aruco_id;
        public string vrpn_id;
        public string name;
        public GameObject origin;
        public bool arucoFound = false;
    }

    public GameObject trackedObject;

    // marker settings
    private Dictionary<string, Panel> _MARKERS = new Dictionary<string, Panel>(){
        {"0", new Panel{aruco_id="0", vrpn_id="QCells"}},
        {"1", new Panel{aruco_id="1", vrpn_id="Hy410"}},
        {"2", new Panel{aruco_id="2", vrpn_id="SIL-410"}}};
        
    // This was autogenerated and allows developers to create a dynamic
    // instance of an InputActionAsset which includes predefined action maps
    // that correspond to all of the Magic Leap 2's input.
    private MagicLeapInputs _magicLeapInputs;
    
    // This class is an Action Map and was autogenerated by the Unity Input
    // System and includes predefined bindings for the Magic Leap 2 Controller
    // Input Events.
    private MagicLeapInputs.ControllerActions _controllerActions;

    private bool _originFinding=true;

    private void Start()
    {
        Debug.Log("OriginTracker::Start()");
        // create a tracker settings object with variables defined above
        MLMarkerTracker.ArucoDictionaryName d = MLMarkerTracker.ArucoDictionaryName.DICT_5X5_100;
        MLMarkerTracker.Profile profile = MLMarkerTracker.Profile.Accuracy;
        // create a tracker settings object with variables defined above
        MLMarkerTracker.TrackerSettings trackerSettings = MLMarkerTracker.TrackerSettings.Create(true, MLMarkerTracker.MarkerType.Aruco_April, 0.07161f, d, 0.07161f, profile);

      //Initialize the MagicLeapInputs like you would Unity's default action map.
       _magicLeapInputs = new MagicLeapInputs();
       _magicLeapInputs.Enable();
       //Initialize the ControllerActions based off the Magic Leap Input
       _controllerActions = new MagicLeapInputs.ControllerActions(_magicLeapInputs);
       _controllerActions.Trigger.started += HandleOnTriggerPull;
       _controllerActions.Trigger.canceled += HandleOnTriggerRelease;

        trackedObject.SetActive(true);
        trackedObject.transform.GetChild(4).gameObject.GetComponent<TextMeshPro>().text = "Release Trigger when aligned";

        // start marker tracking with tracker settings object
        _ = MLMarkerTracker.SetSettingsAsync(trackerSettings);
    }

    // subscribe to the event that detects markers
    private void OnEnable()
    {
        Debug.Log("OriginTracker::OnEnable()");
        MLMarkerTracker.OnMLMarkerTrackerResultsFound += OnTrackerResultsFound;
    }

    // when the marker is detected...
    private void OnTrackerResultsFound(MLMarkerTracker.MarkerData data)
    {
        string id = "";

        if (_originFinding)
        {
            if (data.Type == MLMarkerTracker.MarkerType.Aruco_April)
            {
                id = data.ArucoData.Id.ToString();
            }

            Debug.Log("OriginTracker Detected " + id + " " + _controllerActions.Trigger.ReadValue<float>());

            if (_MARKERS.ContainsKey(id))
            {
                Debug.Log("OriginTracker updating " + id + " " + data.Pose.position);
                this.transform.position = data.Pose.position;// - new Vector3(0.0381f, 0.0f, -0.0381f);
                this.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);

                if (!_MARKERS[id].origin) 
                {
                    _MARKERS[id].origin = Instantiate(trackedObject, data.Pose.position, data.Pose.rotation);
                    _MARKERS[id].origin.transform.GetChild(4).gameObject.GetComponent<TextMeshPro>().text = _MARKERS[id].vrpn_id;
                    _MARKERS[id].origin.transform.up = Vector3.up;
                    _MARKERS[id].origin.SetActive(true);
                    _MARKERS[id].arucoFound = true;
                }

                _MARKERS[id].origin.transform.position = data.Pose.position;
                _MARKERS[id].origin.transform.rotation = data.Pose.rotation * Quaternion.Euler(-90,0,180);
            }

            if (_controllerActions.Trigger.ReadValue<float>()==0)
            {
                var n_root = transform.Find("NoodlesRoot");

                if (n_root) {
                    Debug.Log("OriginTracker: Kicking off transform request");

                    var panel_name = "DTrack";

                    var args = new List<CBORObject>();
                    args.Add(CBORObject.FromObject(panel_name));

                    var comp = n_root.gameObject.GetComponent<NOODLESRoot>();

                    if (comp != null)
                    {
                        Debug.Log("OrignTracker: INVOKE");
                        comp.invoke_method_by_name("get_transform",  args, OnRequestReply);
                    }

                    
                }
                
                Debug.Log("OriginTracker: finished originFinding");
                //_originFinding = false;
            }
        }           
        // stop scanning after object has been instantiated
        //_ = MLMarkerTracker.StopScanningAsync();

    }

    // Handles the event for the Trigger.
    private void HandleOnTriggerPull(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("OriginTracker: Pull. The Trigger value is : " +  triggerValue);
        trackedObject.SetActive(true);
        _originFinding = true;
    }
        private void HandleOnTriggerRelease(InputAction.CallbackContext obj)
    {
        float triggerValue = obj.ReadValue<float>();
        Debug.Log("OriginTracker: Release. The Trigger value is : " +  triggerValue);
        trackedObject.SetActive(false);
        _originFinding = false;

    }

    private void OnRequestReply(CBORObject reply) {
        Debug.Log("OriginTracker: RQ REPLY" + reply.ToString());


        var offset = new Vector3(
            reply[0].ToObject<float>(),
            reply[1].ToObject<float>(), 
            - reply[2].ToObject<float>()
        );

        var rotation = new Quaternion(
            -reply[3].ToObject<float>(),
            -reply[4].ToObject<float>(), 
            reply[5].ToObject<float>(),
            reply[6].ToObject<float>()
        );

        var n_root = transform.Find("NoodlesRoot");

        if (n_root == null)
        {
            Debug.Log("Unable to find root!");
            return;
        }

        n_root.SetLocalPositionAndRotation(offset, rotation);
    }
}
